# Monorepo CI/CD Strategy Implementation Guide
## Using Harness Lightspeed and OpenShift for Microservices

### Executive Summary

This comprehensive guide provides a complete implementation strategy for setting up CI/CD pipelines for a monorepo containing multiple microservices using Harness Lightspeed and OpenShift. The solution addresses the specific requirements of separate build uploads for each service while maintaining shared artifacts for common components across all environments.

### Architecture Overview

Based on your folder structure analysis, the implementation follows these key principles:

1. **Path-based Triggering**: Only build and deploy services that have actual code changes
2. **Separate Artifact Management**: Independent artifacts for common components and each microservice
3. **Environment Consistency**: Artifacts include configurations for all environments (dev, staging, prod)
4. **OpenShift Integration**: Leverage OpenShift's internal registry and deployment capabilities
5. **Harness Orchestration**: Use Harness Lightspeed for pipeline management and deployment automation

## Implementation Strategy

### 1. Repository Structure Organization

Your current structure is well-suited for monorepo CI/CD:

```
/
├── .gitignore
├── pipeline.yaml                 # Main Harness pipeline configuration
├── helm/
│   ├── .helmignore
│   ├── Chart.yaml
│   └── values.yaml              # Base Helm values
├── configs/
│   ├── dev/
│   │   ├── gtlecsdev1/
│   │   │   ├── common/          # Shared configurations
│   │   │   ├── certs/           # Environment certificates
│   │   │   └── services/        # Service-specific configs
│   │   └── gtlecsdev2/
│   ├── staging/                 # Staging environment configs
│   └── prod/                    # Production environment configs
└── services/
    ├── common/                  # Shared libraries and utilities
    ├── user-service/            # Individual microservice
    ├── order-service/           # Individual microservice
    └── notification-service/    # Individual microservice
```

### 2. Harness CI Pipeline Configuration

#### Path-Based Change Detection

The CI pipeline uses intelligent change detection to trigger builds only for modified components:

```yaml
# Check for changes in specific paths
steps:
  - step:
      type: Run
      name: Detect-Changes
      spec:
        shell: Sh
        command: |
          # Detect common library changes
          git diff --name-only HEAD~1 HEAD | grep -E "^(common/|shared/)" > /dev/null && echo "COMMON_CHANGED=true" || echo "COMMON_CHANGED=false"
          
          # Detect service-specific changes
          git diff --name-only HEAD~1 HEAD | grep -E "^services/user-service/" > /dev/null && echo "USER_SERVICE_CHANGED=true" || echo "USER_SERVICE_CHANGED=false"
          
          # Detect configuration changes
          git diff --name-only HEAD~1 HEAD | grep -E "^(helm/|configs/)" > /dev/null && echo "CONFIG_CHANGED=true" || echo "CONFIG_CHANGED=false"
```

#### Parallel Build Strategy

Services are built in parallel when changes are detected, optimizing build time:

```yaml
parallel:
  - step:
      name: Build-Common
      when:
        condition: '<+execution.steps.DetectChanges.output.outputVariables.COMMON_CHANGED> == "true"'
  - step:
      name: Build-User-Service
      when:
        condition: '<+execution.steps.DetectChanges.output.outputVariables.USER_SERVICE_CHANGED> == "true"'
```

### 3. Artifact Management Strategy

#### Separate Artifacts for Each Component

**Common Artifacts**:
- Shared libraries and utilities
- Base Docker images
- Common configuration templates
- Helm chart dependencies

**Service-Specific Artifacts**:
- Compiled application binaries
- Service Docker images
- Service-specific configurations
- Documentation and schemas

#### Multi-Environment Support

Each artifact includes configurations for all environments:

```yaml
# Artifact structure example
monorepo-artifacts/
├── common/
│   ├── v1.2.3/
│   │   ├── dev/
│   │   ├── staging/
│   │   └── prod/
├── user-service/
│   ├── v2.1.0/
│   │   ├── dev/
│   │   ├── staging/
│   │   └── prod/
```

### 4. OpenShift Integration

#### Internal Registry Configuration

Configure OpenShift's internal registry for container image storage:

```bash
# Enable internal registry access
oc patch configs.imageregistry.operator.openshift.io/cluster --patch '{"spec":{"defaultRoute":true}}' --type=merge

# Get registry route
REGISTRY_ROUTE=$(oc get route default-route -n openshift-image-registry -o jsonpath='{.spec.host}')

# Login to registry
docker login -u $(oc whoami) -p $(oc whoami -t) $REGISTRY_ROUTE
```

#### Deployment Manifests

Use Helm charts for consistent deployments across environments:

```yaml
# values-dev.yaml
global:
  environment: dev
  registry: image-registry.openshift-image-registry.svc:5000
  namespace: microservices-dev

commonService:
  enabled: true
  image:
    repository: common-service
    tag: latest
  replicas: 2
  
userService:
  enabled: true
  image:
    repository: user-service
    tag: latest
  replicas: 3
```

### 5. Pipeline Trigger Configuration

#### Webhook-Based Triggers

Configure intelligent triggers that respond to specific path changes:

```yaml
trigger:
  source:
    type: Webhook
    spec:
      type: Github
      spec:
        payloadConditions:
          - key: "changedFiles"
            operator: "Regex" 
            value: ".*(common/|services/|helm/|configs/).*"
```

#### Branch-Based Strategy

- **Feature branches**: Run CI only
- **Development branch**: Run CI + deploy to dev environment
- **Staging branch**: Run CI + deploy to staging environment
- **Main branch**: Run CI + deploy to production (with approval)

### 6. Deployment Strategy

#### Environment Promotion Pipeline

```yaml
stages:
  - stage:
      name: Deploy-to-Dev
      type: Deployment
      spec:
        serviceConfig:
          artifacts:
            primary:
              sources:
                - spec:
                    connectorRef: openshift_registry
                    imagePath: <+service.name>
                    tag: <+pipeline.sequenceId>
  
  - stage:
      name: Deploy-to-Staging
      type: Deployment
      dependsOn: [Deploy-to-Dev]
      
  - stage:
      name: Deploy-to-Production
      type: Deployment
      dependsOn: [Deploy-to-Staging]
      spec:
        execution:
          steps:
            - step:
                type: HarnessApproval
                name: Production-Approval
```

### 7. Best Practices Implementation

#### Build Optimization

1. **Caching Strategy**: Implement build caching for dependencies and intermediate artifacts
2. **Incremental Builds**: Only rebuild changed components and their dependents
3. **Parallel Execution**: Run independent builds simultaneously
4. **Resource Management**: Optimize build resource allocation

#### Security Considerations

1. **Registry Security**: Use OpenShift's built-in RBAC for registry access
2. **Secret Management**: Store sensitive configurations in OpenShift secrets
3. **Image Scanning**: Integrate security scanning in the build pipeline
4. **Access Controls**: Implement proper RBAC for Harness pipelines

#### Monitoring and Observability

1. **Pipeline Metrics**: Track build times, success rates, and failure patterns
2. **Deployment Monitoring**: Monitor application health post-deployment
3. **Cost Optimization**: Track resource usage and optimize accordingly
4. **Alerting**: Set up alerts for pipeline failures and deployment issues

### 8. Implementation Checklist

#### Phase 1: Setup Foundation
- [ ] Configure Harness project and connectors
- [ ] Set up OpenShift clusters for each environment
- [ ] Configure internal registry access
- [ ] Create base Helm charts

#### Phase 2: Implement CI Pipeline
- [ ] Create path-based change detection logic
- [ ] Implement parallel build stages
- [ ] Configure artifact storage and management
- [ ] Set up container image building and pushing

#### Phase 3: Configure CD Pipeline
- [ ] Create environment-specific deployment stages
- [ ] Implement approval workflows
- [ ] Configure rollback strategies
- [ ] Set up monitoring and alerts

#### Phase 4: Testing and Optimization
- [ ] Test end-to-end pipeline execution
- [ ] Optimize build and deployment times
- [ ] Validate artifact management
- [ ] Fine-tune resource allocation

### 9. Troubleshooting Guide

#### Common Issues and Solutions

**Build Performance Issues**:
- Implement build caching
- Optimize Docker image layers
- Use parallel builds for independent services

**Deployment Failures**:
- Verify OpenShift connectivity
- Check resource quotas and limits
- Validate Helm chart configurations

**Registry Issues**:
- Confirm registry access permissions
- Verify image tagging conventions
- Check network connectivity

### 10. Migration Strategy

For migrating from existing CI/CD setups:

1. **Assessment**: Analyze current pipeline configurations
2. **Parallel Running**: Run new pipelines alongside existing ones
3. **Gradual Migration**: Move services one at a time
4. **Validation**: Ensure consistency between old and new deployments
5. **Cutover**: Complete migration after validation

### Conclusion

This monorepo CI/CD strategy provides a scalable, efficient solution for managing multiple microservices while maintaining separation of concerns. The combination of Harness Lightspeed and OpenShift offers powerful automation capabilities with robust deployment orchestration.

The path-based triggering ensures efficient resource utilization, while separate artifact management provides flexibility and environment consistency. This approach supports both current requirements and future scaling needs.

### Next Steps

1. Begin with Phase 1 implementation
2. Set up a pilot service for testing
3. Gradually expand to all services
4. Implement monitoring and optimization
5. Document lessons learned and best practices

This implementation will provide a solid foundation for continuous delivery while maintaining the flexibility and scalability required for microservices architecture.