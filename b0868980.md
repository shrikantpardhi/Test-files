# Monorepo Strategy Files - Complete Implementation

## Overview
This package contains all the required files for implementing a comprehensive monorepo CI/CD strategy using Harness Lightspeed and OpenShift. The implementation creates separate artifacts for common components and individual services while maintaining environment consistency across all deployment targets.

## Package Contents (34 Files)

### Root Level Files (3)
- `.gitignore` - Git ignore patterns for the monorepo
- `pipeline.yaml` - Main Harness CI/CD pipeline configuration with path-based triggering
- `README.md` - Project documentation and usage instructions

### Helm Charts (6)
- `helm/Chart.yaml` - Helm chart metadata and dependencies
- `helm/.helmignore` - Patterns to ignore when building Helm packages
- `helm/values.yaml` - Default Helm values for all environments
- `helm/templates/common-deployment.yaml` - Common service deployment template
- `helm/templates/customer-service-deployment.yaml` - Customer service deployment template  
- `helm/templates/services.yaml` - Kubernetes service definitions

### Configuration Files (8)
- `configs/dev/gtlecsdev1/common/gtlecsdev1.yml` - Base configuration for dev cluster 1
- `configs/dev/gtlecsdev1/common/gtlecsdev1-cyb.yml` - CyberArk configuration for dev cluster 1
- `configs/dev/gtlecsdev1/common/gtlecsdev1-eureka.yml` - Eureka configuration for dev cluster 1
- `configs/dev/gtlecsdev2/common/gtlecsdev2-cyb.yml` - CyberArk configuration for dev cluster 2
- `configs/dev/gtlecsdev2/common/gtlecsdev2-eureka.yml` - Eureka configuration for dev cluster 2
- `configs/dev/gtlecsdev1/cust-c-customeridchanges-chub-ls/CUST-C-CustomerIdChanges-CHUB-LS.yml` - Customer service configuration
- `configs/staging/common/staging-common.yml` - Staging environment common configuration
- `configs/prod/common/prod-common.yml` - Production environment common configuration

### Certificate Files (6)
- `configs/dev/gtlecsdev1/certs/clientDEVcert.jks` - Client certificate for DEV environment
- `configs/dev/gtlecsdev1/certs/CMRDev.jks` - CMR service certificate for DEV environment
- `configs/dev/gtlecsdev1/certs/DEV_cacerts.jks` - CA certificates for DEV environment
- `configs/dev/gtlecsdev1/certs/mdmcerts.jks` - MDM service certificates for DEV environment
- `configs/dev/gtlecsdev2/certs/cmr-eh.gtord-gkbla01d.keytab` - Kerberos keytab for gtlecsdev2
- `configs/dev/gtlecsdev2/certs/krb5.conf` - Kerberos configuration for gtlecsdev2

### Management Scripts (3)
- `scripts/cert-manager.sh` - Certificate validation, copying, and Kubernetes secret creation
- `scripts/build-artifacts.sh` - Comprehensive artifact building for common and service components
- `scripts/deploy-artifacts.sh` - Artifact deployment and Helm-based service deployment

### Deployment Files (7)
- `helm/values-dev-gtlecsdev1.yaml` - Environment-specific values for dev cluster 1
- `helm/values-dev-gtlecsdev2.yaml` - Environment-specific values for dev cluster 2
- `helm/values-staging.yaml` - Environment-specific values for staging
- `helm/values-prod.yaml` - Environment-specific values for production
- `openshift/namespaces.yaml` - OpenShift namespace definitions for all environments
- `openshift/configmaps.yaml` - ConfigMap templates for OpenShift deployment
- Various deployment configuration files

### Documentation (2)
- `IMPLEMENTATION_GUIDE.md` - Comprehensive implementation guide with step-by-step instructions
- `ARTIFACTS_STRATEGY.md` - Detailed artifact management strategy and best practices

## Key Features Implemented

### 1. Path-based CI/CD Triggering
- Intelligent change detection using git diff analysis
- Builds only components that have changed
- Supports parallel building of independent services
- Conditional pipeline execution based on detected changes

### 2. Separate Artifact Management
- **Common Artifacts**: Environment-specific configurations, certificates, and shared resources
- **Service Artifacts**: Service-specific configurations and deployment manifests
- Each artifact includes configurations for all environments (dev, staging, prod)
- Versioned artifacts with comprehensive metadata

### 3. Environment-Specific Configurations
- **Development**: Two clusters (gtlecsdev1, gtlecsdev2) with different configurations
- **Staging**: Pre-production testing environment with enhanced resources
- **Production**: High-availability configuration with optimal resource allocation

### 4. Certificate Management Automation
- Automated certificate validation and deployment
- Support for JKS keystores and Kerberos keytabs
- Kubernetes secret creation from certificate artifacts
- Environment-specific certificate organization

### 5. OpenShift Integration
- Native OpenShift deployment support
- Internal registry integration for container images
- Route and service configuration
- Namespace management and RBAC

### 6. Helm Chart Templates
- Comprehensive Helm charts for all services
- Environment-specific value files
- ConfigMap and Secret integration
- Rolling deployment and health check support

## Artifact Strategy

### Common Artifacts Structure
```
common-artifacts-<build_id>/
├── metadata.json                    # Build metadata and version info
├── dev/                            # Development environment configs
│   ├── gtlecsdev1/                 # Cluster 1 configurations
│   └── gtlecsdev2/                 # Cluster 2 configurations
├── staging/                        # Staging environment configs
├── prod/                           # Production environment configs
└── certs/                          # Environment-specific certificates
    ├── dev/
    ├── staging/
    └── prod/
```

### Service Artifacts Structure
```
<service-name>-artifacts-<build_id>/
├── metadata.json                    # Service-specific metadata
├── dev/                            # Development configurations
├── staging/                        # Staging configurations
└── prod/                           # Production configurations
```

## Usage Instructions

### 1. Initial Setup
```bash
# Make scripts executable
chmod +x scripts/*.sh

# Validate current environment
./scripts/cert-manager.sh validate dev gtlecsdev1

# List available services
./scripts/build-artifacts.sh list
```

### 2. Building Artifacts
```bash
# Build all artifacts
./scripts/build-artifacts.sh all

# Build only common artifacts
./scripts/build-artifacts.sh common

# Build specific service artifacts
./scripts/build-artifacts.sh service cust-c-customeridchanges-chub-ls
```

### 3. Deployment
```bash
# Deploy to development environment
ENVIRONMENT=dev CLUSTER=gtlecsdev1 ./scripts/deploy-artifacts.sh full

# Deploy to staging
ENVIRONMENT=staging ./scripts/deploy-artifacts.sh full

# Deploy to production  
ENVIRONMENT=prod ./scripts/deploy-artifacts.sh full
```

## Implementation Steps

### Phase 1: Repository Setup
1. Initialize your monorepo with these files
2. Replace placeholder certificates with actual certificates
3. Update configuration files with environment-specific values
4. Commit initial file structure to your repository

### Phase 2: Harness Configuration
1. Create Harness project for microservices
2. Import the pipeline.yaml configuration
3. Configure connectors (GitHub, OpenShift, Artifactory)
4. Set up webhook triggers for automatic builds

### Phase 3: OpenShift Preparation
1. Create namespaces using `openshift/namespaces.yaml`
2. Configure OpenShift registry access
3. Set up RBAC for Harness service accounts
4. Deploy initial ConfigMaps and Secrets

### Phase 4: Testing and Deployment
1. Run initial build to create artifacts
2. Deploy to development environment first
3. Test service connectivity and functionality
4. Promote to staging and production environments

## Benefits

1. **Efficiency**: Only builds and deploys changed components
2. **Scalability**: Easily add new services without pipeline modifications
3. **Consistency**: Shared artifacts ensure consistent dependencies
4. **Environment Parity**: Identical configurations across environments
5. **Automation**: Minimal manual intervention required
6. **Security**: Proper certificate and secret management
7. **Monitoring**: Built-in health checks and deployment verification

## Customization Notes

### Environment-Specific Updates Required
- Database connection strings and credentials
- External service endpoints and API keys
- Certificate files and passwords
- Kerberos configuration details
- Kafka topic names and broker addresses

### Service Extension
To add new services:
1. Create service-specific configuration directory under `configs/*/`
2. Add service deployment template to `helm/templates/`
3. Update `helm/values*.yaml` files with service configuration
4. Service will be automatically detected by build scripts

## Support and Troubleshooting

### Common Issues
- **Certificate validation failures**: Check certificate formats and permissions
- **Build failures**: Verify Git change detection logic and file paths
- **Deployment issues**: Confirm OpenShift connectivity and resource availability
- **Configuration errors**: Validate YAML syntax and environment values

### Debug Commands
```bash
# Check artifact contents
tar -tzf common-artifacts-<build_id>.tar.gz

# Validate Helm charts
helm lint ./helm --values ./helm/values-dev-gtlecsdev1.yaml

# Verify OpenShift resources
kubectl get all -n microservices-dev-gtlecsdev1

# Test certificate validity
keytool -list -keystore configs/dev/gtlecsdev1/certs/clientDEVcert.jks
```

This complete implementation provides a production-ready monorepo strategy that addresses all your requirements for separate artifact management, environment consistency, and automated CI/CD deployment using Harness Lightspeed and OpenShift.