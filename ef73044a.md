# 🛍️ **E-Commerce Order Management System Example Prompt**

Using the **Generic Multi-Step Spring Boot Project Prompt Template**

---

## 🧩 **STEP 1 — Generate Entities and DTOs**

You are an expert Java backend engineer and software architect.  

Generate a complete set of **JPA entity classes and corresponding DTOs** for an e-commerce order management system based on the following complex SQL queries and schema requirements.

### INPUT
**Complex SQL Query with Multiple Joins and Conditions:**

```sql
-- Get order details with customer info, products, inventory, and payment status
SELECT DISTINCT
    o.order_id,
    o.order_number,
    o.order_date,
    o.total_amount,
    o.order_status,
    o.shipping_address,
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.phone_number,
    c.customer_tier,
    c.registration_date,
    oi.order_item_id,
    oi.quantity,
    oi.unit_price,
    oi.discount_amount,
    p.product_id,
    p.product_name,
    p.sku,
    p.brand,
    p.category_id,
    p.base_price,
    p.weight,
    cat.category_name,
    cat.parent_category_id,
    i.inventory_id,
    i.available_quantity,
    i.reserved_quantity,
    i.warehouse_location,
    pay.payment_id,
    pay.payment_method,
    pay.payment_status,
    pay.transaction_id,
    pay.payment_amount,
    pay.payment_date,
    s.shipping_id,
    s.tracking_number,
    s.carrier,
    s.shipping_method,
    s.estimated_delivery,
    s.actual_delivery,
    s.shipping_status,
    d.discount_id,
    d.discount_code,
    d.discount_type,
    d.discount_value,
    d.valid_from,
    d.valid_until
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id
LEFT JOIN inventory i ON p.product_id = i.product_id
LEFT JOIN payments pay ON o.order_id = pay.order_id
LEFT JOIN shipping s ON o.order_id = s.order_id
LEFT JOIN order_discounts od ON o.order_id = od.order_id
LEFT JOIN discounts d ON od.discount_id = d.discount_id
WHERE o.order_date >= DATEADD(MONTH, -6, GETDATE())
  AND c.customer_tier IN ('PREMIUM', 'GOLD', 'PLATINUM')
  AND p.category_id IN (
    SELECT category_id FROM categories 
    WHERE category_name IN ('Electronics', 'Fashion', 'Home & Garden')
       OR parent_category_id IN (1, 5, 8)
  )
  AND i.available_quantity >= oi.quantity
  AND (pay.payment_status = 'COMPLETED' OR pay.payment_status IS NULL)
  AND (d.valid_until IS NULL OR d.valid_until >= GETDATE())
  AND o.total_amount > 100.00
ORDER BY o.order_date DESC, c.customer_tier, p.category_id;

-- Complex aggregation query for reporting
SELECT 
    c.customer_tier,
    cat.category_name,
    COUNT(DISTINCT o.order_id) as total_orders,
    COUNT(DISTINCT oi.order_item_id) as total_items,
    SUM(oi.quantity * oi.unit_price) as gross_revenue,
    SUM(oi.discount_amount) as total_discounts,
    AVG(o.total_amount) as average_order_value,
    COUNT(DISTINCT CASE WHEN s.shipping_status = 'DELIVERED' THEN o.order_id END) as delivered_orders,
    AVG(DATEDIFF(DAY, o.order_date, s.actual_delivery)) as avg_delivery_days
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id
LEFT JOIN shipping s ON o.order_id = s.order_id
LEFT JOIN payments pay ON o.order_id = pay.order_id
WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND pay.payment_status = 'COMPLETED'
  AND c.customer_tier IS NOT NULL
GROUP BY c.customer_tier, cat.category_name
HAVING COUNT(DISTINCT o.order_id) >= 5
   AND SUM(oi.quantity * oi.unit_price) > 1000.00
ORDER BY gross_revenue DESC, total_orders DESC;
```

**Database Schema Requirements:**
- Target database: PostgreSQL 15+
- Java version: 17+
- Spring Boot version: 3.2.x (latest stable)
- Required field types: LocalDateTime for dates, BigDecimal for money amounts, enums for status fields
- Audit fields: created_date, updated_date, created_by, updated_by on all entities
- Soft delete support with deleted_date field

### OBJECTIVE
1. Infer entities, fields, types, and relationships from the complex SQL queries above
2. Generate JPA entities for: Customer, Order, OrderItem, Product, Category, Inventory, Payment, Shipping, Discount, OrderDiscount
3. Include complex relationships:
   - OneToMany: Customer→Orders, Order→OrderItems, Category→Products, Order→Payments
   - ManyToOne: OrderItem→Product, Product→Category, Order→Customer
   - ManyToMany: Order↔Discount (via OrderDiscount join table)
   - OneToOne: Order↔Shipping
4. Include proper fetch types (LAZY for collections, EAGER for required references)
5. Add cascade rules for parent-child relationships
6. Generate comprehensive DTOs for:
   - OrderSummaryResponseDTO (with customer and item details)
   - OrderCreateRequestDTO (with validation constraints)
   - OrderReportDTO (for aggregation queries)
   - CustomerOrderHistoryDTO
   - ProductInventoryDTO
7. Include audit fields and soft delete functionality
8. Add enums for status fields (OrderStatus, PaymentStatus, ShippingStatus, CustomerTier, etc.)

---

## 🧩 **STEP 2 — Implement Business Logic, Validation, and Configuration**

You are now implementing the service, repository, controller, and core infrastructure for the e-commerce order management system.

### INPUT
- Entities and DTOs generated in Step 1
- Complex business requirements with advanced queries and workflows
- Multi-datasource configuration requirements

### Business Requirements:
1. **Order Management:**
   - Create orders with inventory validation
   - Update order status with business rules
   - Cancel orders with refund processing
   - Calculate discounts and taxes automatically

2. **Complex Query Requirements:**
   - Search orders with multiple filters (date range, customer tier, product category, payment status)
   - Generate sales reports with grouping and aggregation
   - Find customers with specific purchase patterns
   - Inventory availability checks with reserved quantity logic

3. **Advanced Workflows:**
   - Order processing pipeline with status transitions
   - Automatic payment verification and retry logic
   - Shipping integration with tracking updates
   - Customer tier calculation based on purchase history

### OBJECTIVE
1. Create repositories with complex custom queries using @Query annotations and Criteria API
2. Implement advanced repository methods:
   - `findOrdersWithFilters(CustomerTier tier, List<Long> categoryIds, LocalDateTime fromDate, LocalDateTime toDate, Pageable pageable)`
   - `generateSalesReport(LocalDateTime startDate, LocalDateTime endDate, List<String> groupBy)`
   - `findCustomersWithPurchasePattern(BigDecimal minAmount, Integer minOrders, List<Long> productIds)`
   - `checkInventoryAvailability(Map<Long, Integer> productQuantities)`

3. Create service implementations with complex business logic:
   - OrderService: order creation, status management, cancellation logic
   - PaymentService: payment processing, retry mechanisms, refund handling
   - InventoryService: stock management, reservation logic, reorder point calculations
   - ReportService: sales analytics, customer insights, inventory reports

4. Create REST controllers with advanced endpoints:
   - GET `/api/orders/search` with complex query parameters
   - POST `/api/orders/{id}/process` for order processing workflow
   - GET `/api/reports/sales` with grouping and filtering options
   - GET `/api/customers/{id}/purchase-history` with pagination and sorting

5. Apply comprehensive validation:
   - Order total validation against line items
   - Inventory availability validation
   - Customer tier-based discount validation
   - Payment amount validation
   - Date range validation for reports

6. Add global exception handling for:
   - InsufficientInventoryException
   - PaymentProcessingException
   - InvalidOrderStatusTransitionException
   - CustomerTierValidationException

7. Configure infrastructure:
   - PostgreSQL datasource with connection pooling
   - Redis caching for frequently accessed data
   - Async processing for order notifications
   - OpenAPI documentation with complex schema examples

8. Implement unit and integration tests for:
   - Complex repository queries
   - Order processing workflows
   - Payment processing scenarios
   - Inventory management logic

---

## 🧩 **STEP 3 — Implement Response Mapping and JSON Wrappers**

You are now implementing the mapping layer and standardized JSON responses for the e-commerce system.

### INPUT
- Complex entities and DTOs from Step 1
- Advanced services and controllers from Step 2

### OBJECTIVE
1. Implement sophisticated entity-to-DTO mapping with:
   - Nested object mapping (Order → Customer, OrderItems → Products)
   - Conditional mapping based on user roles and context
   - Aggregation mapping for report DTOs
   - Collection mapping with filtering and sorting

2. Create mapping utilities for:
   - Order entity to OrderSummaryResponseDTO with customer and product details
   - Complex aggregation results to ReportDTO objects
   - Customer entity to CustomerOrderHistoryDTO with order statistics
   - Product entity to ProductInventoryDTO with stock information

3. Implement contextual mapping:
   - Different DTO mappings for admin vs customer views
   - Sensitive data filtering based on user permissions
   - Localization support for category names and product descriptions

4. Standardize JSON responses with enhanced wrapper:
   ```json
   {
     "status": "SUCCESS",
     "message": "Orders retrieved successfully",
     "data": { /* mapped DTO data */ },
     "metadata": {
       "totalCount": 150,
       "currentPage": 1,
       "totalPages": 15,
       "pageSize": 10
     },
     "timestamp": "2024-10-07T13:30:00Z",
     "requestId": "req-12345",
     "version": "v1.0"
   }
   ```

5. Integrate advanced mapping features:
   - Lazy loading prevention in DTO mapping
   - Circular reference handling
   - Performance optimization for large datasets
   - Caching of frequently mapped objects

---

## ✅ **USAGE INSTRUCTIONS**

1. **Run Step 1** → Generates complex entities and DTOs for e-commerce system
2. **Run Step 2** → Implements advanced repositories, services, controllers with complex queries and business logic
3. **Run Step 3** → Adds sophisticated mapping layer with contextual DTOs and enhanced JSON responses

---

## 🎯 **Expected Outcome**

A production-ready Spring Boot e-commerce order management system with:
- 10+ JPA entities with complex relationships
- Advanced repository layer with custom queries and aggregations
- Sophisticated business logic handling real-world e-commerce scenarios
- Comprehensive validation and exception handling
- Complex DTO mapping with contextual transformations
- Standardized API responses with metadata and pagination
- Complete test coverage for critical business flows

This example demonstrates the template's capability to handle enterprise-level complexity with multiple joins, conditional logic, and advanced Spring Boot features.