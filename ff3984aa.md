# GitHub Copilot Agent Template: Spring Boot Microservice Generator

This template provides a comprehensive multi-step approach to generate a complete Spring Boot microservice using GitHub Copilot agents. The template ensures the generated application follows best practices and is directly runnable without manual code changes.

## Prerequisites

Before using this template, ensure you have:
- GitHub Copilot enabled in your IDE
- Java 17+ installed
- Maven 3.6+ installed
- Your existing parent POM details (if applicable)

## Multi-Step Prompt Template

### Step 1: Project Structure and Foundation

```
Create a Spring Boot microservice project with the following specifications:

**Project Details:**
- Project Name: [PROJECT_NAME]
- Group ID: [GROUP_ID] (e.g., com.company.microservices)
- Artifact ID: [ARTIFACT_ID] (e.g., user-service)
- Package Name: [PACKAGE_NAME] (e.g., com.company.microservices.userservice)
- Java Version: 17
- Spring Boot Version: 3.2.0

**Parent POM (if applicable):**
- Parent Group ID: [PARENT_GROUP_ID]
- Parent Artifact ID: [PARENT_ARTIFACT_ID]
- Parent Version: [PARENT_VERSION]

**Required Dependencies:**
- spring-boot-starter-web
- spring-boot-starter-data-jpa
- spring-boot-starter-validation
- spring-boot-starter-actuator
- spring-boot-starter-security (basic setup)
- springdoc-openapi-starter-webmvc-ui (for Swagger)
- mysql-connector-java or postgresql (database driver: [DATABASE_TYPE])
- lombok
- mapstruct
- spring-boot-starter-test

**Project Structure:**
Generate the following folder structure:
```
src/main/java/[PACKAGE_PATH]/
├── [ARTIFACT_ID]Application.java (main class)
├── config/
│   ├── DatabaseConfig.java
│   ├── SecurityConfig.java
│   └── OpenApiConfig.java
├── controller/
├── service/
│   └── impl/
├── repository/
├── entity/
├── dto/
│   ├── request/
│   └── response/
├── util/
│   ├── mapper/
│   └── constants/
└── exception/
    ├── GlobalExceptionHandler.java
    └── custom/
```

**Configuration Files:**
1. application.yml with profiles (dev, prod)
2. bootstrap.yml for configuration management
3. logback-spring.xml for logging configuration

**Application Configuration (application.yml):**
```yaml
server:
  port: [PORT_NUMBER]
  servlet:
    context-path: /api/v1

spring:
  application:
    name: [ARTIFACT_ID]
  profiles:
    active: dev
  datasource:
    url: jdbc:[DATABASE_TYPE]://localhost:3306/[DATABASE_NAME]
    username: [DB_USERNAME]
    password: [DB_PASSWORD]
    driver-class-name: [DRIVER_CLASS]
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: [HIBERNATE_DIALECT]
        format_sql: true
  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.xml

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    [PACKAGE_NAME]: DEBUG
    org.springframework.security: DEBUG
```

**OpenAPI Configuration:**
Create OpenApiConfig.java with title: "[SERVICE_TITLE]", version: "1.0.0", description: "[SERVICE_DESCRIPTION]"

Ensure all classes follow the controller-service-repository architecture pattern with proper dependency injection and exception handling.
```

### Step 2: Database Schema and Entity Generation

```
Based on the following SQL schema, generate JPA entities with relationships and corresponding repositories:

**Database Schema:**
```sql
[PASTE_YOUR_SQL_SCHEMA_HERE]
-- Example:
-- CREATE TABLE users (
--     id BIGINT PRIMARY KEY AUTO_INCREMENT,
--     username VARCHAR(50) UNIQUE NOT NULL,
--     email VARCHAR(100) UNIQUE NOT NULL,
--     first_name VARCHAR(50) NOT NULL,
--     last_name VARCHAR(50) NOT NULL,
--     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
--     updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-- );
```

**Requirements:**
1. Generate JPA entities in the entity package with:
   - Proper JPA annotations (@Entity, @Table, @Id, @GeneratedValue, etc.)
   - Lombok annotations (@Data, @NoArgsConstructor, @AllArgsConstructor, @Builder)
   - Validation annotations where appropriate
   - Audit fields (createdAt, updatedAt) with @CreationTimestamp and @UpdateTimestamp
   - Proper relationships (@OneToMany, @ManyToOne, @ManyToMany) based on foreign keys

2. Generate corresponding repository interfaces extending JpaRepository:
   - Include custom query methods based on common search patterns
   - Add @Repository annotation
   - Include methods for: findByActive, findByCreatedAtBetween, etc.

3. Create Liquibase changelog files in src/main/resources/db/changelog/:
   - db.changelog-master.xml (master file)
   - Individual changelog files for each table creation

**Request/Response JSON Examples:**
```json
[PASTE_YOUR_REQUEST_RESPONSE_JSON_EXAMPLES]
// Example:
// Request JSON for creating user:
// {
//   "username": "john_doe",
//   "email": "john@example.com",
//   "firstName": "John",
//   "lastName": "Doe"
// }
//
// Response JSON:
// {
//   "id": 1,
//   "username": "john_doe",
//   "email": "john@example.com",
//   "firstName": "John",
//   "lastName": "Doe",
//   "createdAt": "2024-01-15T10:30:00Z"
// }
```

Generate corresponding DTOs in dto/request and dto/response packages with:
- Validation annotations (@NotNull, @Email, @Size, etc.)
- JsonProperty annotations for proper JSON mapping
- Lombok annotations for getters/setters
- MapStruct mappers in util/mapper package for entity-DTO conversion
```

### Step 3: API Implementation

```
Generate REST API implementation based on the following specifications:

**API Endpoints and Requirements:**
[DEFINE_YOUR_APIS_HERE]
// Example:
// POST /api/v1/users - Create new user
// GET /api/v1/users/{id} - Get user by ID
// GET /api/v1/users - Get users with pagination and filtering
// PUT /api/v1/users/{id} - Update user
// DELETE /api/v1/users/{id} - Delete user

**Specific API Requirements:**

1. **[API_ENDPOINT_1]**: [METHOD] [URL]
   - Description: [DESCRIPTION]
   - Request: [REQUEST_DTO_CLASS]
   - Response: [RESPONSE_DTO_CLASS]
   - Business Logic: [BUSINESS_REQUIREMENTS]

2. **[API_ENDPOINT_2]**: [METHOD] [URL]
   - Description: [DESCRIPTION]
   - Query Parameters: [QUERY_PARAMS]
   - Response: [RESPONSE_DTO_CLASS]

**Database Queries:**
For complex data retrieval, implement the following SQL-based criteria queries:

```sql
[PASTE_YOUR_COMPLEX_SQL_QUERIES]
-- Example:
-- SELECT u.*, p.name as profile_name 
-- FROM users u 
-- LEFT JOIN profiles p ON u.profile_id = p.id 
-- WHERE u.active = true 
-- AND u.created_at BETWEEN ? AND ?
-- ORDER BY u.created_at DESC
```

**Implementation Requirements:**

1. **Controller Layer:**
   - Generate REST controllers with proper annotations (@RestController, @RequestMapping)
   - Include comprehensive OpenAPI documentation (@Operation, @ApiResponse, @Parameter)
   - Implement proper validation using @Valid
   - Add proper HTTP status codes and response handling
   - Include CORS configuration if needed

2. **Service Layer:**
   - Create service interfaces and implementations
   - Implement business logic and validation
   - Add @Transactional annotations where appropriate
   - Include proper exception handling with custom exceptions
   - Implement pagination using Pageable for list endpoints

3. **Repository Layer:**
   - Create custom query methods using @Query annotation for complex SQL
   - Implement Criteria API queries for dynamic filtering
   - Add proper result mapping to DTOs using @SqlResultSetMapping if needed

4. **Utility and Helper Classes:**
   - Generate MapStruct mappers for entity-DTO conversion
   - Create utility classes for common operations
   - Add constants classes for magic numbers and strings

5. **Exception Handling:**
   - Implement @ControllerAdvice for global exception handling
   - Create custom exceptions (ResourceNotFoundException, ValidationException, etc.)
   - Return proper error responses with meaningful messages

6. **Testing:**
   - Generate unit tests for service layer using JUnit 5 and Mockito
   - Create integration tests for controller layer using @SpringBootTest
   - Include test data setup and cleanup

**Response Format:**
Ensure all API responses follow this format:
```json
{
  "status": "success|error",
  "message": "Operation completed successfully",
  "data": {actual_response_data},
  "timestamp": "2024-01-15T10:30:00Z"
}
```

Generate all code ensuring:
- No manual configuration required
- Application is directly runnable
- All dependencies are properly injected
- Proper error handling and logging
- Clean code following SOLID principles
- Comprehensive validation and security measures
```

## Usage Instructions

1. **Replace Placeholders:** Update all placeholders marked with `[PLACEHOLDER_NAME]` with actual values
2. **Execute Step by Step:** Run each prompt separately in GitHub Copilot Chat
3. **Review Generated Code:** Ensure all generated classes follow the expected structure
4. **Test Application:** Run the application and verify all endpoints work correctly

## Customization Options

- **Database Type:** Modify database driver and dialect based on your database choice (MySQL, PostgreSQL, etc.)
- **Security:** Adjust security configuration based on authentication requirements (JWT, OAuth2, etc.)
- **Monitoring:** Add additional monitoring and metrics as needed
- **Documentation:** Customize OpenAPI documentation with additional details

## Example Usage

```
Step 1 Prompt:
Create a Spring Boot microservice project with the following specifications:

Project Details:
- Project Name: User Management Service
- Group ID: com.company.microservices
- Artifact ID: user-service
- Package Name: com.company.microservices.userservice
- Java Version: 17
- Spring Boot Version: 3.2.0

[Continue with the rest of Step 1 template...]
```

This template ensures that your Spring Boot microservice is generated with all necessary components and follows industry best practices while being directly executable without manual intervention.